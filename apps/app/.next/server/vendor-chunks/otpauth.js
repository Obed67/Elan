"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/otpauth";
exports.ids = ["vendor-chunks/otpauth"];
exports.modules = {

/***/ "(rsc)/../../node_modules/otpauth/dist/otpauth.node.mjs":
/*!********************************************************!*\
  !*** ../../node_modules/otpauth/dist/otpauth.node.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HOTP: () => (/* binding */ HOTP),\n/* harmony export */   Secret: () => (/* binding */ Secret),\n/* harmony export */   TOTP: () => (/* binding */ TOTP),\n/* harmony export */   URI: () => (/* binding */ URI),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n//! otpauth 9.3.6 | (c) Héctor Molinero Fernández | MIT | https://github.com/hectorm/otpauth\n/// <reference types=\"./otpauth.d.ts\" />\n// @ts-nocheck\n\n\n/**\n * Converts an integer to an Uint8Array.\n * @param {number} num Integer.\n * @returns {Uint8Array} Uint8Array.\n */ const uintDecode = (num)=>{\n    const buf = new ArrayBuffer(8);\n    const arr = new Uint8Array(buf);\n    let acc = num;\n    for(let i = 7; i >= 0; i--){\n        if (acc === 0) break;\n        arr[i] = acc & 255;\n        acc -= arr[i];\n        acc /= 256;\n    }\n    return arr;\n};\n\n/**\n * \"globalThis\" ponyfill.\n * @see [A horrifying globalThis polyfill in universal JavaScript](https://mathiasbynens.be/notes/globalthis)\n * @type {Object.<string, *>}\n */ const globalScope = (()=>{\n    if (typeof globalThis === \"object\") return globalThis;\n    else {\n        Object.defineProperty(Object.prototype, \"__GLOBALTHIS__\", {\n            get () {\n                return this;\n            },\n            configurable: true\n        });\n        try {\n            // @ts-expect-error\n            // eslint-disable-next-line no-undef\n            if (typeof __GLOBALTHIS__ !== \"undefined\") return __GLOBALTHIS__;\n        } finally{\n            // @ts-expect-error\n            delete Object.prototype.__GLOBALTHIS__;\n        }\n    }\n    // Still unable to determine \"globalThis\", fall back to a naive method.\n    if (typeof self !== \"undefined\") return self;\n    else if (typeof window !== \"undefined\") return window;\n    else if (typeof global !== \"undefined\") return global;\n    return undefined;\n})();\n\n/**\n * Canonicalizes a hash algorithm name.\n * @param {string} algorithm Hash algorithm name.\n * @returns {\"SHA1\"|\"SHA224\"|\"SHA256\"|\"SHA384\"|\"SHA512\"|\"SHA3-224\"|\"SHA3-256\"|\"SHA3-384\"|\"SHA3-512\"} Canonicalized hash algorithm name.\n */ const canonicalizeAlgorithm = (algorithm)=>{\n    switch(true){\n        case /^(?:SHA-?1|SSL3-SHA1)$/i.test(algorithm):\n            return \"SHA1\";\n        case /^SHA(?:2?-)?224$/i.test(algorithm):\n            return \"SHA224\";\n        case /^SHA(?:2?-)?256$/i.test(algorithm):\n            return \"SHA256\";\n        case /^SHA(?:2?-)?384$/i.test(algorithm):\n            return \"SHA384\";\n        case /^SHA(?:2?-)?512$/i.test(algorithm):\n            return \"SHA512\";\n        case /^SHA3-224$/i.test(algorithm):\n            return \"SHA3-224\";\n        case /^SHA3-256$/i.test(algorithm):\n            return \"SHA3-256\";\n        case /^SHA3-384$/i.test(algorithm):\n            return \"SHA3-384\";\n        case /^SHA3-512$/i.test(algorithm):\n            return \"SHA3-512\";\n        default:\n            throw new TypeError(`Unknown hash algorithm: ${algorithm}`);\n    }\n};\n/**\n * Calculates an HMAC digest.\n * @param {string} algorithm Algorithm.\n * @param {Uint8Array} key Key.\n * @param {Uint8Array} message Message.\n * @returns {Uint8Array} Digest.\n */ const hmacDigest = (algorithm, key, message)=>{\n    if (/*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))?.createHmac) {\n        const hmac = node_crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(algorithm, globalScope.Buffer.from(key));\n        hmac.update(globalScope.Buffer.from(message));\n        return hmac.digest();\n    } else {\n        throw new Error(\"Missing HMAC function\");\n    }\n};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */ const ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n/**\n * Converts a base32 string to an Uint8Array (RFC 4648).\n * @see [LinusU/base32-decode](https://github.com/LinusU/base32-decode)\n * @param {string} str Base32 string.\n * @returns {Uint8Array} Uint8Array.\n */ const base32Decode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    // Canonicalize to all upper case and remove padding if it exists.\n    let end = str.length;\n    while(str[end - 1] === \"=\")--end;\n    str = (end < str.length ? str.substring(0, end) : str).toUpperCase();\n    const buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n    const arr = new Uint8Array(buf);\n    let bits = 0;\n    let value = 0;\n    let index = 0;\n    for(let i = 0; i < str.length; i++){\n        const idx = ALPHABET.indexOf(str[i]);\n        if (idx === -1) throw new TypeError(`Invalid character found: ${str[i]}`);\n        value = value << 5 | idx;\n        bits += 5;\n        if (bits >= 8) {\n            bits -= 8;\n            arr[index++] = value >>> bits;\n        }\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a base32 string (RFC 4648).\n * @see [LinusU/base32-encode](https://github.com/LinusU/base32-encode)\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Base32 string.\n */ const base32Encode = (arr)=>{\n    let bits = 0;\n    let value = 0;\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        value = value << 8 | arr[i];\n        bits += 8;\n        while(bits >= 5){\n            str += ALPHABET[value >>> bits - 5 & 31];\n            bits -= 5;\n        }\n    }\n    if (bits > 0) {\n        str += ALPHABET[value << 5 - bits & 31];\n    }\n    return str;\n};\n\n/**\n * Converts a hexadecimal string to an Uint8Array.\n * @param {string} str Hexadecimal string.\n * @returns {Uint8Array} Uint8Array.\n */ const hexDecode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    const buf = new ArrayBuffer(str.length / 2);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i += 2){\n        arr[i / 2] = parseInt(str.substring(i, i + 2), 16);\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a hexadecimal string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Hexadecimal string.\n */ const hexEncode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        const hex = arr[i].toString(16);\n        if (hex.length === 1) str += \"0\";\n        str += hex;\n    }\n    return str.toUpperCase();\n};\n\n/**\n * Converts a Latin-1 string to an Uint8Array.\n * @param {string} str Latin-1 string.\n * @returns {Uint8Array} Uint8Array.\n */ const latin1Decode = (str)=>{\n    const buf = new ArrayBuffer(str.length);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i++){\n        arr[i] = str.charCodeAt(i) & 0xff;\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a Latin-1 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Latin-1 string.\n */ const latin1Encode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        str += String.fromCharCode(arr[i]);\n    }\n    return str;\n};\n\n/**\n * TextEncoder instance.\n * @type {TextEncoder|null}\n */ const ENCODER = globalScope.TextEncoder ? new globalScope.TextEncoder() : null;\n/**\n * TextDecoder instance.\n * @type {TextDecoder|null}\n */ const DECODER = globalScope.TextDecoder ? new globalScope.TextDecoder() : null;\n/**\n * Converts an UTF-8 string to an Uint8Array.\n * @param {string} str String.\n * @returns {Uint8Array} Uint8Array.\n */ const utf8Decode = (str)=>{\n    if (!ENCODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return ENCODER.encode(str);\n};\n/**\n * Converts an Uint8Array to an UTF-8 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} String.\n */ const utf8Encode = (arr)=>{\n    if (!DECODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return DECODER.decode(arr);\n};\n\n/**\n * Returns random bytes.\n * @param {number} size Size.\n * @returns {Uint8Array} Random bytes.\n */ const randomBytes = (size)=>{\n    if (/*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))?.randomBytes) {\n        return node_crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes(size);\n    } else if (globalScope.crypto?.getRandomValues) {\n        return globalScope.crypto.getRandomValues(new Uint8Array(size));\n    } else {\n        throw new Error(\"Cryptography API not available\");\n    }\n};\n\n/**\n * OTP secret key.\n */ class Secret {\n    /**\n   * Converts a Latin-1 string to a Secret object.\n   * @param {string} str Latin-1 string.\n   * @returns {Secret} Secret object.\n   */ static fromLatin1(str) {\n        return new Secret({\n            buffer: latin1Decode(str).buffer\n        });\n    }\n    /**\n   * Converts an UTF-8 string to a Secret object.\n   * @param {string} str UTF-8 string.\n   * @returns {Secret} Secret object.\n   */ static fromUTF8(str) {\n        return new Secret({\n            buffer: utf8Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a base32 string to a Secret object.\n   * @param {string} str Base32 string.\n   * @returns {Secret} Secret object.\n   */ static fromBase32(str) {\n        return new Secret({\n            buffer: base32Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a hexadecimal string to a Secret object.\n   * @param {string} str Hexadecimal string.\n   * @returns {Secret} Secret object.\n   */ static fromHex(str) {\n        return new Secret({\n            buffer: hexDecode(str).buffer\n        });\n    }\n    /**\n   * Secret key buffer.\n   * @deprecated For backward compatibility, the \"bytes\" property should be used instead.\n   * @type {ArrayBufferLike}\n   */ get buffer() {\n        return this.bytes.buffer;\n    }\n    /**\n   * Latin-1 string representation of secret key.\n   * @type {string}\n   */ get latin1() {\n        Object.defineProperty(this, \"latin1\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: latin1Encode(this.bytes)\n        });\n        return this.latin1;\n    }\n    /**\n   * UTF-8 string representation of secret key.\n   * @type {string}\n   */ get utf8() {\n        Object.defineProperty(this, \"utf8\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: utf8Encode(this.bytes)\n        });\n        return this.utf8;\n    }\n    /**\n   * Base32 string representation of secret key.\n   * @type {string}\n   */ get base32() {\n        Object.defineProperty(this, \"base32\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: base32Encode(this.bytes)\n        });\n        return this.base32;\n    }\n    /**\n   * Hexadecimal string representation of secret key.\n   * @type {string}\n   */ get hex() {\n        Object.defineProperty(this, \"hex\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: hexEncode(this.bytes)\n        });\n        return this.hex;\n    }\n    /**\n   * Creates a secret key object.\n   * @param {Object} [config] Configuration options.\n   * @param {ArrayBufferLike} [config.buffer] Secret key buffer.\n   * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n   */ constructor({ buffer, size = 20 } = {}){\n        /**\n     * Secret key.\n     * @type {Uint8Array}\n     * @readonly\n     */ this.bytes = typeof buffer === \"undefined\" ? randomBytes(size) : new Uint8Array(buffer);\n        // Prevent the \"bytes\" property from being modified.\n        Object.defineProperty(this, \"bytes\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: this.bytes\n        });\n    }\n}\n\n/**\n * Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values.\n * @param {string} a String a.\n * @param {string} b String b.\n * @returns {boolean} Equality result.\n */ const timingSafeEqual = (a, b)=>{\n    if (/*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))?.timingSafeEqual) {\n        return node_crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(globalScope.Buffer.from(a), globalScope.Buffer.from(b));\n    } else {\n        if (a.length !== b.length) {\n            throw new TypeError(\"Input strings must have the same length\");\n        }\n        let i = -1;\n        let out = 0;\n        while(++i < a.length){\n            out |= a.charCodeAt(i) ^ b.charCodeAt(i);\n        }\n        return out === 0;\n    }\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm.\n * @see [RFC 4226](https://datatracker.ietf.org/doc/html/rfc4226)\n */ class HOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   counter: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            counter: 0,\n            window: 1\n        };\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter }) {\n        const digest = hmacDigest(algorithm, secret.bytes, uintDecode(counter));\n        const offset = digest[digest.byteLength - 1] & 15;\n        const otp = ((digest[offset] & 127) << 24 | (digest[offset + 1] & 255) << 16 | (digest[offset + 2] & 255) << 8 | digest[offset + 3] & 255) % 10 ** digits;\n        return otp.toString().padStart(digits, \"0\");\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.counter=this.counter++] Counter value.\n   * @returns {string} Token.\n   */ generate({ counter = this.counter++ } = {}) {\n        return HOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter\n        });\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter, window = HOTP.defaults.window }) {\n        // Return early if the token length does not match the digit number.\n        if (token.length !== digits) return null;\n        let delta = null;\n        const check = (/** @type {number} */ i)=>{\n            const generatedToken = HOTP.generate({\n                secret,\n                algorithm,\n                digits,\n                counter: i\n            });\n            if (timingSafeEqual(token, generatedToken)) {\n                delta = i - counter;\n            }\n        };\n        check(counter);\n        for(let i = 1; i <= window && delta === null; ++i){\n            check(counter - i);\n            if (delta !== null) break;\n            check(counter + i);\n            if (delta !== null) break;\n        }\n        return delta;\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.counter=this.counter] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, counter = this.counter, window }) {\n        return HOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://hotp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `counter=${e(this.counter)}`;\n    }\n    /**\n   * Creates an HOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Initial counter value.\n   */ constructor({ issuer = HOTP.defaults.issuer, label = HOTP.defaults.label, issuerInLabel = HOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Initial counter value.\n     * @type {number}\n     */ this.counter = counter;\n    }\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm.\n * @see [RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238)\n */ class TOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   period: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            period: 30,\n            window: 1\n        };\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now() }) {\n        return HOTP.generate({\n            secret,\n            algorithm,\n            digits,\n            counter: Math.floor(timestamp / 1000 / period)\n        });\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ generate({ timestamp = Date.now() } = {}) {\n        return TOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now(), window }) {\n        return HOTP.validate({\n            token,\n            secret,\n            algorithm,\n            digits,\n            counter: Math.floor(timestamp / 1000 / period),\n            window\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, timestamp, window }) {\n        return TOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://totp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `period=${e(this.period)}`;\n    }\n    /**\n   * Creates a TOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   */ constructor({ issuer = TOTP.defaults.issuer, label = TOTP.defaults.label, issuerInLabel = TOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = TOTP.defaults.algorithm, digits = TOTP.defaults.digits, period = TOTP.defaults.period } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Token time-step duration.\n     * @type {number}\n     */ this.period = period;\n    }\n}\n\n/**\n * Key URI regex (otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS).\n * @type {RegExp}\n */ const OTPURI_REGEX = /^otpauth:\\/\\/([ht]otp)\\/(.+)\\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;\n/**\n * RFC 4648 base32 alphabet with pad.\n * @type {RegExp}\n */ const SECRET_REGEX = /^[2-7A-Z]+=*$/i;\n/**\n * Regex for supported algorithms.\n * @type {RegExp}\n */ const ALGORITHM_REGEX = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;\n/**\n * Integer regex.\n * @type {RegExp}\n */ const INTEGER_REGEX = /^[+-]?\\d+$/;\n/**\n * Positive integer regex.\n * @type {RegExp}\n */ const POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n/**\n * HOTP/TOTP object/string conversion.\n * @see [Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)\n */ class URI {\n    /**\n   * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n   * @param {string} uri Google Authenticator Key URI.\n   * @returns {HOTP|TOTP} HOTP/TOTP object.\n   */ static parse(uri) {\n        let uriGroups;\n        try {\n            uriGroups = uri.match(OTPURI_REGEX);\n        // eslint-disable-next-line no-unused-vars\n        } catch (_) {\n        /* Handled below */ }\n        if (!Array.isArray(uriGroups)) {\n            throw new URIError(\"Invalid URI format\");\n        }\n        // Extract URI groups.\n        const uriType = uriGroups[1].toLowerCase();\n        const uriLabel = uriGroups[2].split(/(?::|%3A) *(.+)/i, 2).map(decodeURIComponent);\n        /** @type {Object.<string, string>} */ const uriParams = uriGroups[3].split(\"&\").reduce((acc, cur)=>{\n            const pairArr = cur.split(/=(.*)/, 2).map(decodeURIComponent);\n            const pairKey = pairArr[0].toLowerCase();\n            const pairVal = pairArr[1];\n            /** @type {Object.<string, string>} */ const pairAcc = acc;\n            pairAcc[pairKey] = pairVal;\n            return pairAcc;\n        }, {});\n        // 'OTP' will be instantiated with 'config' argument.\n        let OTP;\n        const config = {};\n        if (uriType === \"hotp\") {\n            OTP = HOTP;\n            // Counter: required\n            if (typeof uriParams.counter !== \"undefined\" && INTEGER_REGEX.test(uriParams.counter)) {\n                config.counter = parseInt(uriParams.counter, 10);\n            } else {\n                throw new TypeError(\"Missing or invalid 'counter' parameter\");\n            }\n        } else if (uriType === \"totp\") {\n            OTP = TOTP;\n            // Period: optional\n            if (typeof uriParams.period !== \"undefined\") {\n                if (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n                    config.period = parseInt(uriParams.period, 10);\n                } else {\n                    throw new TypeError(\"Invalid 'period' parameter\");\n                }\n            }\n        } else {\n            throw new TypeError(\"Unknown OTP type\");\n        }\n        // Label: required\n        // Issuer: optional\n        if (typeof uriParams.issuer !== \"undefined\") {\n            config.issuer = uriParams.issuer;\n        }\n        if (uriLabel.length === 2) {\n            config.label = uriLabel[1];\n            if (typeof config.issuer === \"undefined\" || config.issuer === \"\") {\n                config.issuer = uriLabel[0];\n            } else if (uriLabel[0] === \"\") {\n                config.issuerInLabel = false;\n            }\n        } else {\n            config.label = uriLabel[0];\n            if (typeof config.issuer !== \"undefined\" && config.issuer !== \"\") {\n                config.issuerInLabel = false;\n            }\n        }\n        // Secret: required\n        if (typeof uriParams.secret !== \"undefined\" && SECRET_REGEX.test(uriParams.secret)) {\n            config.secret = uriParams.secret;\n        } else {\n            throw new TypeError(\"Missing or invalid 'secret' parameter\");\n        }\n        // Algorithm: optional\n        if (typeof uriParams.algorithm !== \"undefined\") {\n            if (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n                config.algorithm = uriParams.algorithm;\n            } else {\n                throw new TypeError(\"Invalid 'algorithm' parameter\");\n            }\n        }\n        // Digits: optional\n        if (typeof uriParams.digits !== \"undefined\") {\n            if (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n                config.digits = parseInt(uriParams.digits, 10);\n            } else {\n                throw new TypeError(\"Invalid 'digits' parameter\");\n            }\n        }\n        return new OTP(config);\n    }\n    /**\n   * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n   * @param {HOTP|TOTP} otp HOTP/TOTP object.\n   * @returns {string} Google Authenticator Key URI.\n   */ static stringify(otp) {\n        if (otp instanceof HOTP || otp instanceof TOTP) {\n            return otp.toString();\n        }\n        throw new TypeError(\"Invalid 'HOTP/TOTP' object\");\n    }\n}\n\n/**\n * Library version.\n * @type {string}\n */ const version = \"9.3.6\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL290cGF1dGgvZGlzdC9vdHBhdXRoLm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDc0M7O0FBRXRDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSx3RkFBd0Y7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQSxRQUFRLDJNQUFNO0FBQ2QscUJBQXFCLG1EQUFpQjtBQUN0QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0Esd0VBQXdF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QTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUU0QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BlbGFuL2FwcC8uLi8uLi9ub2RlX21vZHVsZXMvb3RwYXV0aC9kaXN0L290cGF1dGgubm9kZS5tanM/NTE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgb3RwYXV0aCA5LjMuNiB8IChjKSBIw6ljdG9yIE1vbGluZXJvIEZlcm7DoW5kZXogfCBNSVQgfCBodHRwczovL2dpdGh1Yi5jb20vaGVjdG9ybS9vdHBhdXRoXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIi4vb3RwYXV0aC5kLnRzXCIgLz5cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGludGVnZXIgdG8gYW4gVWludDhBcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gSW50ZWdlci5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBVaW50OEFycmF5LlxuICovIGNvbnN0IHVpbnREZWNvZGUgPSAobnVtKT0+e1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGxldCBhY2MgPSBudW07XG4gICAgZm9yKGxldCBpID0gNzsgaSA+PSAwOyBpLS0pe1xuICAgICAgICBpZiAoYWNjID09PSAwKSBicmVhaztcbiAgICAgICAgYXJyW2ldID0gYWNjICYgMjU1O1xuICAgICAgICBhY2MgLT0gYXJyW2ldO1xuICAgICAgICBhY2MgLz0gMjU2O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBcImdsb2JhbFRoaXNcIiBwb255ZmlsbC5cbiAqIEBzZWUgW0EgaG9ycmlmeWluZyBnbG9iYWxUaGlzIHBvbHlmaWxsIGluIHVuaXZlcnNhbCBKYXZhU2NyaXB0XShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpcylcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgKj59XG4gKi8gY29uc3QgZ2xvYmFsU2NvcGUgPSAoKCk9PntcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX0dMT0JBTFRISVNfX1wiLCB7XG4gICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfX0dMT0JBTFRISVNfXyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIF9fR0xPQkFMVEhJU19fO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX0dMT0JBTFRISVNfXztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGlsbCB1bmFibGUgdG8gZGV0ZXJtaW5lIFwiZ2xvYmFsVGhpc1wiLCBmYWxsIGJhY2sgdG8gYSBuYWl2ZSBtZXRob2QuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gc2VsZjtcbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93O1xuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBnbG9iYWw7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn0pKCk7XG5cbi8qKlxuICogQ2Fub25pY2FsaXplcyBhIGhhc2ggYWxnb3JpdGhtIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtIEhhc2ggYWxnb3JpdGhtIG5hbWUuXG4gKiBAcmV0dXJucyB7XCJTSEExXCJ8XCJTSEEyMjRcInxcIlNIQTI1NlwifFwiU0hBMzg0XCJ8XCJTSEE1MTJcInxcIlNIQTMtMjI0XCJ8XCJTSEEzLTI1NlwifFwiU0hBMy0zODRcInxcIlNIQTMtNTEyXCJ9IENhbm9uaWNhbGl6ZWQgaGFzaCBhbGdvcml0aG0gbmFtZS5cbiAqLyBjb25zdCBjYW5vbmljYWxpemVBbGdvcml0aG0gPSAoYWxnb3JpdGhtKT0+e1xuICAgIHN3aXRjaCh0cnVlKXtcbiAgICAgICAgY2FzZSAvXig/OlNIQS0/MXxTU0wzLVNIQTEpJC9pLnRlc3QoYWxnb3JpdGhtKTpcbiAgICAgICAgICAgIHJldHVybiBcIlNIQTFcIjtcbiAgICAgICAgY2FzZSAvXlNIQSg/OjI/LSk/MjI0JC9pLnRlc3QoYWxnb3JpdGhtKTpcbiAgICAgICAgICAgIHJldHVybiBcIlNIQTIyNFwiO1xuICAgICAgICBjYXNlIC9eU0hBKD86Mj8tKT8yNTYkL2kudGVzdChhbGdvcml0aG0pOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0hBMjU2XCI7XG4gICAgICAgIGNhc2UgL15TSEEoPzoyPy0pPzM4NCQvaS50ZXN0KGFsZ29yaXRobSk6XG4gICAgICAgICAgICByZXR1cm4gXCJTSEEzODRcIjtcbiAgICAgICAgY2FzZSAvXlNIQSg/OjI/LSk/NTEyJC9pLnRlc3QoYWxnb3JpdGhtKTpcbiAgICAgICAgICAgIHJldHVybiBcIlNIQTUxMlwiO1xuICAgICAgICBjYXNlIC9eU0hBMy0yMjQkL2kudGVzdChhbGdvcml0aG0pOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0hBMy0yMjRcIjtcbiAgICAgICAgY2FzZSAvXlNIQTMtMjU2JC9pLnRlc3QoYWxnb3JpdGhtKTpcbiAgICAgICAgICAgIHJldHVybiBcIlNIQTMtMjU2XCI7XG4gICAgICAgIGNhc2UgL15TSEEzLTM4NCQvaS50ZXN0KGFsZ29yaXRobSk6XG4gICAgICAgICAgICByZXR1cm4gXCJTSEEzLTM4NFwiO1xuICAgICAgICBjYXNlIC9eU0hBMy01MTIkL2kudGVzdChhbGdvcml0aG0pOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0hBMy01MTJcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gaGFzaCBhbGdvcml0aG06ICR7YWxnb3JpdGhtfWApO1xuICAgIH1cbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgYW4gSE1BQyBkaWdlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtIEFsZ29yaXRobS5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5IEtleS5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbWVzc2FnZSBNZXNzYWdlLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IERpZ2VzdC5cbiAqLyBjb25zdCBobWFjRGlnZXN0ID0gKGFsZ29yaXRobSwga2V5LCBtZXNzYWdlKT0+e1xuICAgIGlmIChjcnlwdG8/LmNyZWF0ZUhtYWMpIHtcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ29yaXRobSwgZ2xvYmFsU2NvcGUuQnVmZmVyLmZyb20oa2V5KSk7XG4gICAgICAgIGhtYWMudXBkYXRlKGdsb2JhbFNjb3BlLkJ1ZmZlci5mcm9tKG1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIGhtYWMuZGlnZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBITUFDIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUkZDIDQ2NDggYmFzZTMyIGFscGhhYmV0IHdpdGhvdXQgcGFkLlxuICogQHR5cGUge3N0cmluZ31cbiAqLyBjb25zdCBBTFBIQUJFVCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIjtcbi8qKlxuICogQ29udmVydHMgYSBiYXNlMzIgc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkgKFJGQyA0NjQ4KS5cbiAqIEBzZWUgW0xpbnVzVS9iYXNlMzItZGVjb2RlXShodHRwczovL2dpdGh1Yi5jb20vTGludXNVL2Jhc2UzMi1kZWNvZGUpXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEJhc2UzMiBzdHJpbmcuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVWludDhBcnJheS5cbiAqLyBjb25zdCBiYXNlMzJEZWNvZGUgPSAoc3RyKT0+e1xuICAgIC8vIFJlbW92ZSBzcGFjZXMgKGFsdGhvdWdoIHRoZXkgYXJlIG5vdCBhbGxvd2VkIGJ5IHRoZSBzcGVjLCBzb21lIGlzc3VlcnMgYWRkIHRoZW0gZm9yIHJlYWRhYmlsaXR5KS5cbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvIC9nLCBcIlwiKTtcbiAgICAvLyBDYW5vbmljYWxpemUgdG8gYWxsIHVwcGVyIGNhc2UgYW5kIHJlbW92ZSBwYWRkaW5nIGlmIGl0IGV4aXN0cy5cbiAgICBsZXQgZW5kID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShzdHJbZW5kIC0gMV0gPT09IFwiPVwiKS0tZW5kO1xuICAgIHN0ciA9IChlbmQgPCBzdHIubGVuZ3RoID8gc3RyLnN1YnN0cmluZygwLCBlbmQpIDogc3RyKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzdHIubGVuZ3RoICogNSAvIDggfCAwKTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGlkeCA9IEFMUEhBQkVULmluZGV4T2Yoc3RyW2ldKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGZvdW5kOiAke3N0cltpXX1gKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA8PCA1IHwgaWR4O1xuICAgICAgICBiaXRzICs9IDU7XG4gICAgICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gODtcbiAgICAgICAgICAgIGFycltpbmRleCsrXSA9IHZhbHVlID4+PiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBVaW50OEFycmF5IHRvIGEgYmFzZTMyIHN0cmluZyAoUkZDIDQ2NDgpLlxuICogQHNlZSBbTGludXNVL2Jhc2UzMi1lbmNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9MaW51c1UvYmFzZTMyLWVuY29kZSlcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlMzIgc3RyaW5nLlxuICovIGNvbnN0IGJhc2UzMkVuY29kZSA9IChhcnIpPT57XG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPDwgOCB8IGFycltpXTtcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB3aGlsZShiaXRzID49IDUpe1xuICAgICAgICAgICAgc3RyICs9IEFMUEhBQkVUW3ZhbHVlID4+PiBiaXRzIC0gNSAmIDMxXTtcbiAgICAgICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYml0cyA+IDApIHtcbiAgICAgICAgc3RyICs9IEFMUEhBQkVUW3ZhbHVlIDw8IDUgLSBiaXRzICYgMzFdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhbiBVaW50OEFycmF5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBIZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVWludDhBcnJheS5cbiAqLyBjb25zdCBoZXhEZWNvZGUgPSAoc3RyKT0+e1xuICAgIC8vIFJlbW92ZSBzcGFjZXMgKGFsdGhvdWdoIHRoZXkgYXJlIG5vdCBhbGxvd2VkIGJ5IHRoZSBzcGVjLCBzb21lIGlzc3VlcnMgYWRkIHRoZW0gZm9yIHJlYWRhYmlsaXR5KS5cbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvIC9nLCBcIlwiKTtcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCAvIDIpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMil7XG4gICAgICAgIGFycltpIC8gMl0gPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcbi8qKlxuICogQ29udmVydHMgYW4gVWludDhBcnJheSB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi8gY29uc3QgaGV4RW5jb2RlID0gKGFycik9PntcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaGV4ID0gYXJyW2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEpIHN0ciArPSBcIjBcIjtcbiAgICAgICAgc3RyICs9IGhleDtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIExhdGluLTEgc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIExhdGluLTEgc3RyaW5nLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVpbnQ4QXJyYXkuXG4gKi8gY29uc3QgbGF0aW4xRGVjb2RlID0gKHN0cik9PntcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYXJyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcbi8qKlxuICogQ29udmVydHMgYW4gVWludDhBcnJheSB0byBhIExhdGluLTEgc3RyaW5nLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnIgVWludDhBcnJheS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IExhdGluLTEgc3RyaW5nLlxuICovIGNvbnN0IGxhdGluMUVuY29kZSA9IChhcnIpPT57XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFRleHRFbmNvZGVyIGluc3RhbmNlLlxuICogQHR5cGUge1RleHRFbmNvZGVyfG51bGx9XG4gKi8gY29uc3QgRU5DT0RFUiA9IGdsb2JhbFNjb3BlLlRleHRFbmNvZGVyID8gbmV3IGdsb2JhbFNjb3BlLlRleHRFbmNvZGVyKCkgOiBudWxsO1xuLyoqXG4gKiBUZXh0RGVjb2RlciBpbnN0YW5jZS5cbiAqIEB0eXBlIHtUZXh0RGVjb2RlcnxudWxsfVxuICovIGNvbnN0IERFQ09ERVIgPSBnbG9iYWxTY29wZS5UZXh0RGVjb2RlciA/IG5ldyBnbG9iYWxTY29wZS5UZXh0RGVjb2RlcigpIDogbnVsbDtcbi8qKlxuICogQ29udmVydHMgYW4gVVRGLTggc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZy5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBVaW50OEFycmF5LlxuICovIGNvbnN0IHV0ZjhEZWNvZGUgPSAoc3RyKT0+e1xuICAgIGlmICghRU5DT0RFUikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGluZyBBUEkgbm90IGF2YWlsYWJsZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEVOQ09ERVIuZW5jb2RlKHN0cik7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBVaW50OEFycmF5IHRvIGFuIFVURi04IHN0cmluZy5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYXJyIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcuXG4gKi8gY29uc3QgdXRmOEVuY29kZSA9IChhcnIpPT57XG4gICAgaWYgKCFERUNPREVSKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nIEFQSSBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gREVDT0RFUi5kZWNvZGUoYXJyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyByYW5kb20gYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBTaXplLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFJhbmRvbSBieXRlcy5cbiAqLyBjb25zdCByYW5kb21CeXRlcyA9IChzaXplKT0+e1xuICAgIGlmIChjcnlwdG8/LnJhbmRvbUJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWxTY29wZS5jcnlwdG8/LmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU2NvcGUuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3J5cHRvZ3JhcGh5IEFQSSBub3QgYXZhaWxhYmxlXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogT1RQIHNlY3JldCBrZXkuXG4gKi8gY2xhc3MgU2VjcmV0IHtcbiAgICAvKipcbiAgICogQ29udmVydHMgYSBMYXRpbi0xIHN0cmluZyB0byBhIFNlY3JldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgTGF0aW4tMSBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTZWNyZXR9IFNlY3JldCBvYmplY3QuXG4gICAqLyBzdGF0aWMgZnJvbUxhdGluMShzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWNyZXQoe1xuICAgICAgICAgICAgYnVmZmVyOiBsYXRpbjFEZWNvZGUoc3RyKS5idWZmZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBVVEYtOCBzdHJpbmcgdG8gYSBTZWNyZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFVURi04IHN0cmluZy5cbiAgICogQHJldHVybnMge1NlY3JldH0gU2VjcmV0IG9iamVjdC5cbiAgICovIHN0YXRpYyBmcm9tVVRGOChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWNyZXQoe1xuICAgICAgICAgICAgYnVmZmVyOiB1dGY4RGVjb2RlKHN0cikuYnVmZmVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQ29udmVydHMgYSBiYXNlMzIgc3RyaW5nIHRvIGEgU2VjcmV0IG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBCYXNlMzIgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U2VjcmV0fSBTZWNyZXQgb2JqZWN0LlxuICAgKi8gc3RhdGljIGZyb21CYXNlMzIoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VjcmV0KHtcbiAgICAgICAgICAgIGJ1ZmZlcjogYmFzZTMyRGVjb2RlKHN0cikuYnVmZmVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBTZWNyZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEhleGFkZWNpbWFsIHN0cmluZy5cbiAgICogQHJldHVybnMge1NlY3JldH0gU2VjcmV0IG9iamVjdC5cbiAgICovIHN0YXRpYyBmcm9tSGV4KHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3JldCh7XG4gICAgICAgICAgICBidWZmZXI6IGhleERlY29kZShzdHIpLmJ1ZmZlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFNlY3JldCBrZXkgYnVmZmVyLlxuICAgKiBAZGVwcmVjYXRlZCBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIFwiYnl0ZXNcIiBwcm9wZXJ0eSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiBAdHlwZSB7QXJyYXlCdWZmZXJMaWtlfVxuICAgKi8gZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuYnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICogTGF0aW4tMSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc2VjcmV0IGtleS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovIGdldCBsYXRpbjEoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhdGluMVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBsYXRpbjFFbmNvZGUodGhpcy5ieXRlcylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGluMTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFVURi04IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzZWNyZXQga2V5LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi8gZ2V0IHV0ZjgoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInV0ZjhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXRmOEVuY29kZSh0aGlzLmJ5dGVzKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRmODtcbiAgICB9XG4gICAgLyoqXG4gICAqIEJhc2UzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2Ygc2VjcmV0IGtleS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovIGdldCBiYXNlMzIoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhc2UzMlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBiYXNlMzJFbmNvZGUodGhpcy5ieXRlcylcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2UzMjtcbiAgICB9XG4gICAgLyoqXG4gICAqIEhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzZWNyZXQga2V5LlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi8gZ2V0IGhleCgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGV4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGhleEVuY29kZSh0aGlzLmJ5dGVzKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV4O1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIHNlY3JldCBrZXkgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyTGlrZX0gW2NvbmZpZy5idWZmZXJdIFNlY3JldCBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zaXplPTIwXSBOdW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLCBpZ25vcmVkIGlmICdidWZmZXInIGlzIHByb3ZpZGVkLlxuICAgKi8gY29uc3RydWN0b3IoeyBidWZmZXIsIHNpemUgPSAyMCB9ID0ge30pe1xuICAgICAgICAvKipcbiAgICAgKiBTZWNyZXQga2V5LlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqIEByZWFkb25seVxuICAgICAqLyB0aGlzLmJ5dGVzID0gdHlwZW9mIGJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIiA/IHJhbmRvbUJ5dGVzKHNpemUpIDogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgLy8gUHJldmVudCB0aGUgXCJieXRlc1wiIHByb3BlcnR5IGZyb20gYmVpbmcgbW9kaWZpZWQuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYnl0ZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGlzIGVxdWFsIHRvIGIsIHdpdGhvdXQgbGVha2luZyB0aW1pbmcgaW5mb3JtYXRpb24gdGhhdCB3b3VsZCBhbGxvdyBhbiBhdHRhY2tlciB0byBndWVzcyBvbmUgb2YgdGhlIHZhbHVlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhIFN0cmluZyBhLlxuICogQHBhcmFtIHtzdHJpbmd9IGIgU3RyaW5nIGIuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gRXF1YWxpdHkgcmVzdWx0LlxuICovIGNvbnN0IHRpbWluZ1NhZmVFcXVhbCA9IChhLCBiKT0+e1xuICAgIGlmIChjcnlwdG8/LnRpbWluZ1NhZmVFcXVhbCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChnbG9iYWxTY29wZS5CdWZmZXIuZnJvbShhKSwgZ2xvYmFsU2NvcGUuQnVmZmVyLmZyb20oYikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnB1dCBzdHJpbmdzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgbGV0IG91dCA9IDA7XG4gICAgICAgIHdoaWxlKCsraSA8IGEubGVuZ3RoKXtcbiAgICAgICAgICAgIG91dCB8PSBhLmNoYXJDb2RlQXQoaSkgXiBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dCA9PT0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhPVFA6IEFuIEhNQUMtYmFzZWQgT25lLXRpbWUgUGFzc3dvcmQgQWxnb3JpdGhtLlxuICogQHNlZSBbUkZDIDQyMjZdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDIyNilcbiAqLyBjbGFzcyBIT1RQIHtcbiAgICAvKipcbiAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICAgKiBAdHlwZSB7e1xuICAgKiAgIGlzc3Vlcjogc3RyaW5nLFxuICAgKiAgIGxhYmVsOiBzdHJpbmcsXG4gICAqICAgaXNzdWVySW5MYWJlbDogYm9vbGVhbixcbiAgICogICBhbGdvcml0aG06IHN0cmluZyxcbiAgICogICBkaWdpdHM6IG51bWJlcixcbiAgICogICBjb3VudGVyOiBudW1iZXJcbiAgICogICB3aW5kb3c6IG51bWJlclxuICAgKiB9fVxuICAgKi8gc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzc3VlcjogXCJcIixcbiAgICAgICAgICAgIGxhYmVsOiBcIk9UUEF1dGhcIixcbiAgICAgICAgICAgIGlzc3VlckluTGFiZWw6IHRydWUsXG4gICAgICAgICAgICBhbGdvcml0aG06IFwiU0hBMVwiLFxuICAgICAgICAgICAgZGlnaXRzOiA2LFxuICAgICAgICAgICAgY291bnRlcjogMCxcbiAgICAgICAgICAgIHdpbmRvdzogMVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICogR2VuZXJhdGVzIGFuIEhPVFAgdG9rZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1NlY3JldH0gY29uZmlnLnNlY3JldCBTZWNyZXQga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5hbGdvcml0aG09J1NIQTEnXSBITUFDIGhhc2hpbmcgYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5kaWdpdHM9Nl0gVG9rZW4gbGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5jb3VudGVyPTBdIENvdW50ZXIgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRva2VuLlxuICAgKi8gc3RhdGljIGdlbmVyYXRlKHsgc2VjcmV0LCBhbGdvcml0aG0gPSBIT1RQLmRlZmF1bHRzLmFsZ29yaXRobSwgZGlnaXRzID0gSE9UUC5kZWZhdWx0cy5kaWdpdHMsIGNvdW50ZXIgPSBIT1RQLmRlZmF1bHRzLmNvdW50ZXIgfSkge1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBobWFjRGlnZXN0KGFsZ29yaXRobSwgc2VjcmV0LmJ5dGVzLCB1aW50RGVjb2RlKGNvdW50ZXIpKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGlnZXN0W2RpZ2VzdC5ieXRlTGVuZ3RoIC0gMV0gJiAxNTtcbiAgICAgICAgY29uc3Qgb3RwID0gKChkaWdlc3Rbb2Zmc2V0XSAmIDEyNykgPDwgMjQgfCAoZGlnZXN0W29mZnNldCArIDFdICYgMjU1KSA8PCAxNiB8IChkaWdlc3Rbb2Zmc2V0ICsgMl0gJiAyNTUpIDw8IDggfCBkaWdlc3Rbb2Zmc2V0ICsgM10gJiAyNTUpICUgMTAgKiogZGlnaXRzO1xuICAgICAgICByZXR1cm4gb3RwLnRvU3RyaW5nKCkucGFkU3RhcnQoZGlnaXRzLCBcIjBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gSE9UUCB0b2tlbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuY291bnRlcj10aGlzLmNvdW50ZXIrK10gQ291bnRlciB2YWx1ZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVG9rZW4uXG4gICAqLyBnZW5lcmF0ZSh7IGNvdW50ZXIgPSB0aGlzLmNvdW50ZXIrKyB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIEhPVFAuZ2VuZXJhdGUoe1xuICAgICAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgICAgIGFsZ29yaXRobTogdGhpcy5hbGdvcml0aG0sXG4gICAgICAgICAgICBkaWdpdHM6IHRoaXMuZGlnaXRzLFxuICAgICAgICAgICAgY291bnRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbiBIT1RQIHRva2VuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy50b2tlbiBUb2tlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtTZWNyZXR9IGNvbmZpZy5zZWNyZXQgU2VjcmV0IGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYWxnb3JpdGhtPSdTSEExJ10gSE1BQyBoYXNoaW5nIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuZGlnaXRzPTZdIFRva2VuIGxlbmd0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuY291bnRlcj0wXSBDb3VudGVyIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy53aW5kb3c9MV0gV2luZG93IG9mIGNvdW50ZXIgdmFsdWVzIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH0gVG9rZW4gZGVsdGEgb3IgbnVsbCBpZiBpdCBpcyBub3QgZm91bmQgaW4gdGhlIHNlYXJjaCB3aW5kb3csIGluIHdoaWNoIGNhc2UgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICovIHN0YXRpYyB2YWxpZGF0ZSh7IHRva2VuLCBzZWNyZXQsIGFsZ29yaXRobSwgZGlnaXRzID0gSE9UUC5kZWZhdWx0cy5kaWdpdHMsIGNvdW50ZXIgPSBIT1RQLmRlZmF1bHRzLmNvdW50ZXIsIHdpbmRvdyA9IEhPVFAuZGVmYXVsdHMud2luZG93IH0pIHtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIHRoZSB0b2tlbiBsZW5ndGggZG9lcyBub3QgbWF0Y2ggdGhlIGRpZ2l0IG51bWJlci5cbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCAhPT0gZGlnaXRzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlbHRhID0gbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoLyoqIEB0eXBlIHtudW1iZXJ9ICovIGkpPT57XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRUb2tlbiA9IEhPVFAuZ2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgICAgICBhbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgZGlnaXRzLFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRpbWluZ1NhZmVFcXVhbCh0b2tlbiwgZ2VuZXJhdGVkVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSBpIC0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2soY291bnRlcik7XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPD0gd2luZG93ICYmIGRlbHRhID09PSBudWxsOyArK2kpe1xuICAgICAgICAgICAgY2hlY2soY291bnRlciAtIGkpO1xuICAgICAgICAgICAgaWYgKGRlbHRhICE9PSBudWxsKSBicmVhaztcbiAgICAgICAgICAgIGNoZWNrKGNvdW50ZXIgKyBpKTtcbiAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICAvKipcbiAgICogVmFsaWRhdGVzIGFuIEhPVFAgdG9rZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnRva2VuIFRva2VuIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5jb3VudGVyPXRoaXMuY291bnRlcl0gQ291bnRlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcud2luZG93PTFdIFdpbmRvdyBvZiBjb3VudGVyIHZhbHVlcyB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9IFRva2VuIGRlbHRhIG9yIG51bGwgaWYgaXQgaXMgbm90IGZvdW5kIGluIHRoZSBzZWFyY2ggd2luZG93LCBpbiB3aGljaCBjYXNlIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAqLyB2YWxpZGF0ZSh7IHRva2VuLCBjb3VudGVyID0gdGhpcy5jb3VudGVyLCB3aW5kb3cgfSkge1xuICAgICAgICByZXR1cm4gSE9UUC52YWxpZGF0ZSh7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHNlY3JldDogdGhpcy5zZWNyZXQsXG4gICAgICAgICAgICBhbGdvcml0aG06IHRoaXMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgZGlnaXRzOiB0aGlzLmRpZ2l0cyxcbiAgICAgICAgICAgIGNvdW50ZXIsXG4gICAgICAgICAgICB3aW5kb3dcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBSZXR1cm5zIGEgR29vZ2xlIEF1dGhlbnRpY2F0b3Iga2V5IFVSSS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVVJJLlxuICAgKi8gdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBcIm90cGF1dGg6Ly9ob3RwL1wiICsgYCR7dGhpcy5pc3N1ZXIubGVuZ3RoID4gMCA/IHRoaXMuaXNzdWVySW5MYWJlbCA/IGAke2UodGhpcy5pc3N1ZXIpfToke2UodGhpcy5sYWJlbCl9P2lzc3Vlcj0ke2UodGhpcy5pc3N1ZXIpfSZgIDogYCR7ZSh0aGlzLmxhYmVsKX0/aXNzdWVyPSR7ZSh0aGlzLmlzc3Vlcil9JmAgOiBgJHtlKHRoaXMubGFiZWwpfT9gfWAgKyBgc2VjcmV0PSR7ZSh0aGlzLnNlY3JldC5iYXNlMzIpfSZgICsgYGFsZ29yaXRobT0ke2UodGhpcy5hbGdvcml0aG0pfSZgICsgYGRpZ2l0cz0ke2UodGhpcy5kaWdpdHMpfSZgICsgYGNvdW50ZXI9JHtlKHRoaXMuY291bnRlcil9YDtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSE9UUCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmlzc3Vlcj0nJ10gQWNjb3VudCBwcm92aWRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubGFiZWw9J09UUEF1dGgnXSBBY2NvdW50IGxhYmVsLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuaXNzdWVySW5MYWJlbD10cnVlXSBJbmNsdWRlIGlzc3VlciBwcmVmaXggaW4gbGFiZWwuXG4gICAqIEBwYXJhbSB7U2VjcmV0fHN0cmluZ30gW2NvbmZpZy5zZWNyZXQ9U2VjcmV0XSBTZWNyZXQga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5hbGdvcml0aG09J1NIQTEnXSBITUFDIGhhc2hpbmcgYWxnb3JpdGhtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5kaWdpdHM9Nl0gVG9rZW4gbGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5jb3VudGVyPTBdIEluaXRpYWwgY291bnRlciB2YWx1ZS5cbiAgICovIGNvbnN0cnVjdG9yKHsgaXNzdWVyID0gSE9UUC5kZWZhdWx0cy5pc3N1ZXIsIGxhYmVsID0gSE9UUC5kZWZhdWx0cy5sYWJlbCwgaXNzdWVySW5MYWJlbCA9IEhPVFAuZGVmYXVsdHMuaXNzdWVySW5MYWJlbCwgc2VjcmV0ID0gbmV3IFNlY3JldCgpLCBhbGdvcml0aG0gPSBIT1RQLmRlZmF1bHRzLmFsZ29yaXRobSwgZGlnaXRzID0gSE9UUC5kZWZhdWx0cy5kaWdpdHMsIGNvdW50ZXIgPSBIT1RQLmRlZmF1bHRzLmNvdW50ZXIgfSA9IHt9KXtcbiAgICAgICAgLyoqXG4gICAgICogQWNjb3VudCBwcm92aWRlci5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqLyB0aGlzLmlzc3VlciA9IGlzc3VlcjtcbiAgICAgICAgLyoqXG4gICAgICogQWNjb3VudCBsYWJlbC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqLyB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIC8qKlxuICAgICAqIEluY2x1ZGUgaXNzdWVyIHByZWZpeCBpbiBsYWJlbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi8gdGhpcy5pc3N1ZXJJbkxhYmVsID0gaXNzdWVySW5MYWJlbDtcbiAgICAgICAgLyoqXG4gICAgICogU2VjcmV0IGtleS5cbiAgICAgKiBAdHlwZSB7U2VjcmV0fVxuICAgICAqLyB0aGlzLnNlY3JldCA9IHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIgPyBTZWNyZXQuZnJvbUJhc2UzMihzZWNyZXQpIDogc2VjcmV0O1xuICAgICAgICAvKipcbiAgICAgKiBITUFDIGhhc2hpbmcgYWxnb3JpdGhtLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovIHRoaXMuYWxnb3JpdGhtID0gY2Fub25pY2FsaXplQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIC8qKlxuICAgICAqIFRva2VuIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqLyB0aGlzLmRpZ2l0cyA9IGRpZ2l0cztcbiAgICAgICAgLyoqXG4gICAgICogSW5pdGlhbCBjb3VudGVyIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovIHRoaXMuY291bnRlciA9IGNvdW50ZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIFRPVFA6IFRpbWUtQmFzZWQgT25lLVRpbWUgUGFzc3dvcmQgQWxnb3JpdGhtLlxuICogQHNlZSBbUkZDIDYyMzhdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjIzOClcbiAqLyBjbGFzcyBUT1RQIHtcbiAgICAvKipcbiAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICAgKiBAdHlwZSB7e1xuICAgKiAgIGlzc3Vlcjogc3RyaW5nLFxuICAgKiAgIGxhYmVsOiBzdHJpbmcsXG4gICAqICAgaXNzdWVySW5MYWJlbDogYm9vbGVhbixcbiAgICogICBhbGdvcml0aG06IHN0cmluZyxcbiAgICogICBkaWdpdHM6IG51bWJlcixcbiAgICogICBwZXJpb2Q6IG51bWJlclxuICAgKiAgIHdpbmRvdzogbnVtYmVyXG4gICAqIH19XG4gICAqLyBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNzdWVyOiBcIlwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiT1RQQXV0aFwiLFxuICAgICAgICAgICAgaXNzdWVySW5MYWJlbDogdHJ1ZSxcbiAgICAgICAgICAgIGFsZ29yaXRobTogXCJTSEExXCIsXG4gICAgICAgICAgICBkaWdpdHM6IDYsXG4gICAgICAgICAgICBwZXJpb2Q6IDMwLFxuICAgICAgICAgICAgd2luZG93OiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBUT1RQIHRva2VuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtTZWNyZXR9IGNvbmZpZy5zZWNyZXQgU2VjcmV0IGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYWxnb3JpdGhtPSdTSEExJ10gSE1BQyBoYXNoaW5nIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuZGlnaXRzPTZdIFRva2VuIGxlbmd0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcucGVyaW9kPTMwXSBUb2tlbiB0aW1lLXN0ZXAgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnRpbWVzdGFtcD1EYXRlLm5vd10gVGltZXN0YW1wIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybnMge3N0cmluZ30gVG9rZW4uXG4gICAqLyBzdGF0aWMgZ2VuZXJhdGUoeyBzZWNyZXQsIGFsZ29yaXRobSwgZGlnaXRzLCBwZXJpb2QgPSBUT1RQLmRlZmF1bHRzLnBlcmlvZCwgdGltZXN0YW1wID0gRGF0ZS5ub3coKSB9KSB7XG4gICAgICAgIHJldHVybiBIT1RQLmdlbmVyYXRlKHtcbiAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgICAgIGRpZ2l0cyxcbiAgICAgICAgICAgIGNvdW50ZXI6IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCAvIHBlcmlvZClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBUT1RQIHRva2VuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy50aW1lc3RhbXA9RGF0ZS5ub3ddIFRpbWVzdGFtcCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRva2VuLlxuICAgKi8gZ2VuZXJhdGUoeyB0aW1lc3RhbXAgPSBEYXRlLm5vdygpIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gVE9UUC5nZW5lcmF0ZSh7XG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxuICAgICAgICAgICAgYWxnb3JpdGhtOiB0aGlzLmFsZ29yaXRobSxcbiAgICAgICAgICAgIGRpZ2l0czogdGhpcy5kaWdpdHMsXG4gICAgICAgICAgICBwZXJpb2Q6IHRoaXMucGVyaW9kLFxuICAgICAgICAgICAgdGltZXN0YW1wXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogVmFsaWRhdGVzIGEgVE9UUCB0b2tlbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcudG9rZW4gVG9rZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7U2VjcmV0fSBjb25maWcuc2VjcmV0IFNlY3JldCBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmFsZ29yaXRobT0nU0hBMSddIEhNQUMgaGFzaGluZyBhbGdvcml0aG0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmRpZ2l0cz02XSBUb2tlbiBsZW5ndGguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnBlcmlvZD0zMF0gVG9rZW4gdGltZS1zdGVwIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy50aW1lc3RhbXA9RGF0ZS5ub3ddIFRpbWVzdGFtcCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLndpbmRvdz0xXSBXaW5kb3cgb2YgY291bnRlciB2YWx1ZXMgdG8gdGVzdC5cbiAgICogQHJldHVybnMge251bWJlcnxudWxsfSBUb2tlbiBkZWx0YSBvciBudWxsIGlmIGl0IGlzIG5vdCBmb3VuZCBpbiB0aGUgc2VhcmNoIHdpbmRvdywgaW4gd2hpY2ggY2FzZSBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgKi8gc3RhdGljIHZhbGlkYXRlKHsgdG9rZW4sIHNlY3JldCwgYWxnb3JpdGhtLCBkaWdpdHMsIHBlcmlvZCA9IFRPVFAuZGVmYXVsdHMucGVyaW9kLCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLCB3aW5kb3cgfSkge1xuICAgICAgICByZXR1cm4gSE9UUC52YWxpZGF0ZSh7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgIGFsZ29yaXRobSxcbiAgICAgICAgICAgIGRpZ2l0cyxcbiAgICAgICAgICAgIGNvdW50ZXI6IE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCAvIHBlcmlvZCksXG4gICAgICAgICAgICB3aW5kb3dcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBUT1RQIHRva2VuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy50b2tlbiBUb2tlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcudGltZXN0YW1wPURhdGUubm93XSBUaW1lc3RhbXAgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy53aW5kb3c9MV0gV2luZG93IG9mIGNvdW50ZXIgdmFsdWVzIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH0gVG9rZW4gZGVsdGEgb3IgbnVsbCBpZiBpdCBpcyBub3QgZm91bmQgaW4gdGhlIHNlYXJjaCB3aW5kb3csIGluIHdoaWNoIGNhc2UgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICovIHZhbGlkYXRlKHsgdG9rZW4sIHRpbWVzdGFtcCwgd2luZG93IH0pIHtcbiAgICAgICAgcmV0dXJuIFRPVFAudmFsaWRhdGUoe1xuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxuICAgICAgICAgICAgYWxnb3JpdGhtOiB0aGlzLmFsZ29yaXRobSxcbiAgICAgICAgICAgIGRpZ2l0czogdGhpcy5kaWdpdHMsXG4gICAgICAgICAgICBwZXJpb2Q6IHRoaXMucGVyaW9kLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgd2luZG93XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogUmV0dXJucyBhIEdvb2dsZSBBdXRoZW50aWNhdG9yIGtleSBVUkkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFVSSS5cbiAgICovIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gXCJvdHBhdXRoOi8vdG90cC9cIiArIGAke3RoaXMuaXNzdWVyLmxlbmd0aCA+IDAgPyB0aGlzLmlzc3VlckluTGFiZWwgPyBgJHtlKHRoaXMuaXNzdWVyKX06JHtlKHRoaXMubGFiZWwpfT9pc3N1ZXI9JHtlKHRoaXMuaXNzdWVyKX0mYCA6IGAke2UodGhpcy5sYWJlbCl9P2lzc3Vlcj0ke2UodGhpcy5pc3N1ZXIpfSZgIDogYCR7ZSh0aGlzLmxhYmVsKX0/YH1gICsgYHNlY3JldD0ke2UodGhpcy5zZWNyZXQuYmFzZTMyKX0mYCArIGBhbGdvcml0aG09JHtlKHRoaXMuYWxnb3JpdGhtKX0mYCArIGBkaWdpdHM9JHtlKHRoaXMuZGlnaXRzKX0mYCArIGBwZXJpb2Q9JHtlKHRoaXMucGVyaW9kKX1gO1xuICAgIH1cbiAgICAvKipcbiAgICogQ3JlYXRlcyBhIFRPVFAgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5pc3N1ZXI9JyddIEFjY291bnQgcHJvdmlkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmxhYmVsPSdPVFBBdXRoJ10gQWNjb3VudCBsYWJlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbY29uZmlnLmlzc3VlckluTGFiZWw9dHJ1ZV0gSW5jbHVkZSBpc3N1ZXIgcHJlZml4IGluIGxhYmVsLlxuICAgKiBAcGFyYW0ge1NlY3JldHxzdHJpbmd9IFtjb25maWcuc2VjcmV0PVNlY3JldF0gU2VjcmV0IGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYWxnb3JpdGhtPSdTSEExJ10gSE1BQyBoYXNoaW5nIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcuZGlnaXRzPTZdIFRva2VuIGxlbmd0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcucGVyaW9kPTMwXSBUb2tlbiB0aW1lLXN0ZXAgZHVyYXRpb24uXG4gICAqLyBjb25zdHJ1Y3Rvcih7IGlzc3VlciA9IFRPVFAuZGVmYXVsdHMuaXNzdWVyLCBsYWJlbCA9IFRPVFAuZGVmYXVsdHMubGFiZWwsIGlzc3VlckluTGFiZWwgPSBUT1RQLmRlZmF1bHRzLmlzc3VlckluTGFiZWwsIHNlY3JldCA9IG5ldyBTZWNyZXQoKSwgYWxnb3JpdGhtID0gVE9UUC5kZWZhdWx0cy5hbGdvcml0aG0sIGRpZ2l0cyA9IFRPVFAuZGVmYXVsdHMuZGlnaXRzLCBwZXJpb2QgPSBUT1RQLmRlZmF1bHRzLnBlcmlvZCB9ID0ge30pe1xuICAgICAgICAvKipcbiAgICAgKiBBY2NvdW50IHByb3ZpZGVyLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovIHRoaXMuaXNzdWVyID0gaXNzdWVyO1xuICAgICAgICAvKipcbiAgICAgKiBBY2NvdW50IGxhYmVsLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgLyoqXG4gICAgICogSW5jbHVkZSBpc3N1ZXIgcHJlZml4IGluIGxhYmVsLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqLyB0aGlzLmlzc3VlckluTGFiZWwgPSBpc3N1ZXJJbkxhYmVsO1xuICAgICAgICAvKipcbiAgICAgKiBTZWNyZXQga2V5LlxuICAgICAqIEB0eXBlIHtTZWNyZXR9XG4gICAgICovIHRoaXMuc2VjcmV0ID0gdHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIiA/IFNlY3JldC5mcm9tQmFzZTMyKHNlY3JldCkgOiBzZWNyZXQ7XG4gICAgICAgIC8qKlxuICAgICAqIEhNQUMgaGFzaGluZyBhbGdvcml0aG0uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi8gdGhpcy5hbGdvcml0aG0gPSBjYW5vbmljYWxpemVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgLyoqXG4gICAgICogVG9rZW4gbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovIHRoaXMuZGlnaXRzID0gZGlnaXRzO1xuICAgICAgICAvKipcbiAgICAgKiBUb2tlbiB0aW1lLXN0ZXAgZHVyYXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi8gdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEtleSBVUkkgcmVnZXggKG90cGF1dGg6Ly9UWVBFL1tJU1NVRVI6XUxBQkVMP1BBUkFNRVRFUlMpLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqLyBjb25zdCBPVFBVUklfUkVHRVggPSAvXm90cGF1dGg6XFwvXFwvKFtodF1vdHApXFwvKC4rKVxcPyhbQS1aMC05Ln5fLV0rPVtePyZdKig/OiZbQS1aMC05Ln5fLV0rPVtePyZdKikqKSQvaTtcbi8qKlxuICogUkZDIDQ2NDggYmFzZTMyIGFscGhhYmV0IHdpdGggcGFkLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqLyBjb25zdCBTRUNSRVRfUkVHRVggPSAvXlsyLTdBLVpdKz0qJC9pO1xuLyoqXG4gKiBSZWdleCBmb3Igc3VwcG9ydGVkIGFsZ29yaXRobXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovIGNvbnN0IEFMR09SSVRITV9SRUdFWCA9IC9eU0hBKD86MXwyMjR8MjU2fDM4NHw1MTJ8My0yMjR8My0yNTZ8My0zODR8My01MTIpJC9pO1xuLyoqXG4gKiBJbnRlZ2VyIHJlZ2V4LlxuICogQHR5cGUge1JlZ0V4cH1cbiAqLyBjb25zdCBJTlRFR0VSX1JFR0VYID0gL15bKy1dP1xcZCskLztcbi8qKlxuICogUG9zaXRpdmUgaW50ZWdlciByZWdleC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi8gY29uc3QgUE9TSVRJVkVfSU5URUdFUl9SRUdFWCA9IC9eXFwrP1sxLTldXFxkKiQvO1xuLyoqXG4gKiBIT1RQL1RPVFAgb2JqZWN0L3N0cmluZyBjb252ZXJzaW9uLlxuICogQHNlZSBbS2V5IFVSSSBGb3JtYXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZ29vZ2xlLWF1dGhlbnRpY2F0b3Ivd2lraS9LZXktVXJpLUZvcm1hdClcbiAqLyBjbGFzcyBVUkkge1xuICAgIC8qKlxuICAgKiBQYXJzZXMgYSBHb29nbGUgQXV0aGVudGljYXRvciBrZXkgVVJJIGFuZCByZXR1cm5zIGFuIEhPVFAvVE9UUCBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgR29vZ2xlIEF1dGhlbnRpY2F0b3IgS2V5IFVSSS5cbiAgICogQHJldHVybnMge0hPVFB8VE9UUH0gSE9UUC9UT1RQIG9iamVjdC5cbiAgICovIHN0YXRpYyBwYXJzZSh1cmkpIHtcbiAgICAgICAgbGV0IHVyaUdyb3VwcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVyaUdyb3VwcyA9IHVyaS5tYXRjaChPVFBVUklfUkVHRVgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAvKiBIYW5kbGVkIGJlbG93ICovIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHVyaUdyb3VwcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVUklFcnJvcihcIkludmFsaWQgVVJJIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IFVSSSBncm91cHMuXG4gICAgICAgIGNvbnN0IHVyaVR5cGUgPSB1cmlHcm91cHNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdXJpTGFiZWwgPSB1cmlHcm91cHNbMl0uc3BsaXQoLyg/Ojp8JTNBKSAqKC4rKS9pLCAyKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgc3RyaW5nPn0gKi8gY29uc3QgdXJpUGFyYW1zID0gdXJpR3JvdXBzWzNdLnNwbGl0KFwiJlwiKS5yZWR1Y2UoKGFjYywgY3VyKT0+e1xuICAgICAgICAgICAgY29uc3QgcGFpckFyciA9IGN1ci5zcGxpdCgvPSguKikvLCAyKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBhaXJLZXkgPSBwYWlyQXJyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBwYWlyVmFsID0gcGFpckFyclsxXTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHN0cmluZz59ICovIGNvbnN0IHBhaXJBY2MgPSBhY2M7XG4gICAgICAgICAgICBwYWlyQWNjW3BhaXJLZXldID0gcGFpclZhbDtcbiAgICAgICAgICAgIHJldHVybiBwYWlyQWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vICdPVFAnIHdpbGwgYmUgaW5zdGFudGlhdGVkIHdpdGggJ2NvbmZpZycgYXJndW1lbnQuXG4gICAgICAgIGxldCBPVFA7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAodXJpVHlwZSA9PT0gXCJob3RwXCIpIHtcbiAgICAgICAgICAgIE9UUCA9IEhPVFA7XG4gICAgICAgICAgICAvLyBDb3VudGVyOiByZXF1aXJlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmlQYXJhbXMuY291bnRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBJTlRFR0VSX1JFR0VYLnRlc3QodXJpUGFyYW1zLmNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNvdW50ZXIgPSBwYXJzZUludCh1cmlQYXJhbXMuY291bnRlciwgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBvciBpbnZhbGlkICdjb3VudGVyJyBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodXJpVHlwZSA9PT0gXCJ0b3RwXCIpIHtcbiAgICAgICAgICAgIE9UUCA9IFRPVFA7XG4gICAgICAgICAgICAvLyBQZXJpb2Q6IG9wdGlvbmFsXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVyaVBhcmFtcy5wZXJpb2QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUE9TSVRJVkVfSU5URUdFUl9SRUdFWC50ZXN0KHVyaVBhcmFtcy5wZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5wZXJpb2QgPSBwYXJzZUludCh1cmlQYXJhbXMucGVyaW9kLCAxMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgJ3BlcmlvZCcgcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIE9UUCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExhYmVsOiByZXF1aXJlZFxuICAgICAgICAvLyBJc3N1ZXI6IG9wdGlvbmFsXG4gICAgICAgIGlmICh0eXBlb2YgdXJpUGFyYW1zLmlzc3VlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uZmlnLmlzc3VlciA9IHVyaVBhcmFtcy5pc3N1ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaUxhYmVsLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uZmlnLmxhYmVsID0gdXJpTGFiZWxbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5pc3N1ZXIgPT09IFwidW5kZWZpbmVkXCIgfHwgY29uZmlnLmlzc3VlciA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5pc3N1ZXIgPSB1cmlMYWJlbFswXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJpTGFiZWxbMF0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuaXNzdWVySW5MYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLmxhYmVsID0gdXJpTGFiZWxbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5pc3N1ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uZmlnLmlzc3VlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5pc3N1ZXJJbkxhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VjcmV0OiByZXF1aXJlZFxuICAgICAgICBpZiAodHlwZW9mIHVyaVBhcmFtcy5zZWNyZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgU0VDUkVUX1JFR0VYLnRlc3QodXJpUGFyYW1zLnNlY3JldCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zZWNyZXQgPSB1cmlQYXJhbXMuc2VjcmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3Npbmcgb3IgaW52YWxpZCAnc2VjcmV0JyBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxnb3JpdGhtOiBvcHRpb25hbFxuICAgICAgICBpZiAodHlwZW9mIHVyaVBhcmFtcy5hbGdvcml0aG0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmIChBTEdPUklUSE1fUkVHRVgudGVzdCh1cmlQYXJhbXMuYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGdvcml0aG0gPSB1cmlQYXJhbXMuYWxnb3JpdGhtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCAnYWxnb3JpdGhtJyBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlnaXRzOiBvcHRpb25hbFxuICAgICAgICBpZiAodHlwZW9mIHVyaVBhcmFtcy5kaWdpdHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmIChQT1NJVElWRV9JTlRFR0VSX1JFR0VYLnRlc3QodXJpUGFyYW1zLmRpZ2l0cykpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZGlnaXRzID0gcGFyc2VJbnQodXJpUGFyYW1zLmRpZ2l0cywgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCAnZGlnaXRzJyBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPVFAoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEhPVFAvVE9UUCBvYmplY3QgdG8gYSBHb29nbGUgQXV0aGVudGljYXRvciBrZXkgVVJJLlxuICAgKiBAcGFyYW0ge0hPVFB8VE9UUH0gb3RwIEhPVFAvVE9UUCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEdvb2dsZSBBdXRoZW50aWNhdG9yIEtleSBVUkkuXG4gICAqLyBzdGF0aWMgc3RyaW5naWZ5KG90cCkge1xuICAgICAgICBpZiAob3RwIGluc3RhbmNlb2YgSE9UUCB8fCBvdHAgaW5zdGFuY2VvZiBUT1RQKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RwLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgJ0hPVFAvVE9UUCcgb2JqZWN0XCIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaWJyYXJ5IHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovIGNvbnN0IHZlcnNpb24gPSBcIjkuMy42XCI7XG5cbmV4cG9ydCB7IEhPVFAsIFNlY3JldCwgVE9UUCwgVVJJLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/otpauth/dist/otpauth.node.mjs\n");

/***/ })

};
;